package org.example.vulns;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.example.vulns.deserialization.Deserialization;
import org.example.vulns.files.ArbitraryFileOverwrite;
import org.example.vulns.files.FileUpload;
import org.example.vulns.files.LocalFileInclusion;
import org.example.vulns.files.PathTraversal;
import org.example.vulns.idor.InsecureDirectObjectReferences;
import org.example.vulns.injection.CrossSiteScripting;
import org.example.vulns.injection.SQLInjection;
import org.example.vulns.rce.RemoteCodeExecution;
import org.example.vulns.redirect.OpenRedirect;
import org.example.vulns.ssrf.ServerSideRequestForgery;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class VulnerabilityLoader {

    private final List<AbstractVulnerabilityData> vulnerabilities = new ArrayList<>();

    private final Logger logger = LogManager.getLogger(VulnerabilityLoader.class);

    public VulnerabilityLoader(String configFilePath) {
        try {
            loadVulnerabilities(configFilePath);
        } catch (IOException e) {
            logger.error("Error loading vulnerabilities from file: {}", e.getMessage());
        }
    }

    private void loadVulnerabilities(String vulnInfoFilePath) throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        JsonNode root = mapper.readTree(new File(vulnInfoFilePath));

        for (JsonNode node : root) {
            String vulnName = node.get("vuln_name").asText();
            List<String> sinkPoints = mapper.convertValue(node.get("sink_points"), List.class);
            List<String> vulnSamples = mapper.convertValue(node.get("vuln_samples"), List.class);
            List<String> vulnPocSamples = mapper.convertValue(node.get("vuln_poc_samples"), List.class);

            AbstractVulnerabilityData vulnerability = createVulnerabilityInstance(vulnName, sinkPoints, vulnSamples, vulnPocSamples);
            if (vulnerability != null) {
                vulnerabilities.add(vulnerability);
            }
        }
    }

    private AbstractVulnerabilityData createVulnerabilityInstance(String vulnName, List<String> sinkPoints, List<String> vulnSamples, List<String> vulnPocSamples) {
        AbstractVulnerabilityData vulnerability;
        switch (vulnName) {
            case "RCE-RemoteCodeExecution":
                vulnerability = new RemoteCodeExecution();
                break;
            case "SSRF-ServerSideRequestForgery":
                vulnerability = new ServerSideRequestForgery();
                break;
            case "LFI-LocalFileInclusion":
                vulnerability = new LocalFileInclusion();
                break;
            case "AFO-ArbitraryFileOverwrite":
                vulnerability = new ArbitraryFileOverwrite();
                break;
            case "SQLI-SQLInjection":
                vulnerability = new SQLInjection();
                break;
            case "XSS-CrossSiteScripting":
                vulnerability = new CrossSiteScripting();
                break;
            case "IDOR-InsecureDirectObjectReferences":
                vulnerability = new InsecureDirectObjectReferences();
                break;
            case "PathTraversal":
                vulnerability = new PathTraversal();
                break;
            case "OpenRedirect":
                vulnerability = new OpenRedirect();
                break;
            case "Deserialization":
                vulnerability = new Deserialization();
                break;
            case "FileUpload":
                vulnerability = new FileUpload();
                break;
            default:
                logger.error("Unknown vulnerability type: {}", vulnName);
                return null;
        }

        vulnerability.getSinkPoints().addAll(sinkPoints);
        vulnerability.getSamples().addAll(vulnSamples);
        vulnerability.getPocSamples().addAll(vulnPocSamples);
        return vulnerability;
    }

    public List<AbstractVulnerabilityData> getVulnerabilities() {
        return vulnerabilities;
    }
}
